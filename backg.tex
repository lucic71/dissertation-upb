\section{Background} \label{sec:bg}
%% https://dl.acm.org/doi/pdf/10.1145/2737924.2737979?casa_token=GNGhq36jtkYAAAAA:0WPAvpuTgdhHooeOdrS3gB8zPfCW4gf0HyEBWv6KJwea8IXpjW6Ja-YA7o7ZJeIg18QN7lGO01c_yQ
%% https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7163211&casa_token=CTb8zMXhG1sAAAAA:CFHcfgeuVw1M3xN0QlT4IA9PQndO_ZbxCj2p5niBJ_zFLtpk8rGTNvy39euK332OE-03Blcbkgtx6Q

This section presents UB optimizations in real-life software projects
such as Linux and OpenBSD. After we presents such examples, we provide
an analysis of the risks they introduce and current solutions that try
to tackle the risks, but are however incomplete. The final part of this
section present the situation of UB optimizations as seen by various
acaedmics and C programmers in the field.

Wang et al.~\cite{wang2012undefined} compiled a list of UB optimizations
that show the dangerous effects of using the UB definition when issuing
compiler optimizations. They created case studies for the following
classes of undefined behaviors: division by zero, oversized shift,
signed integer overflow, out-of-bounds pointer, null pointer
dereference, type-punned pointer dereference and uninitialized read. The
consequences of these optimizations range from unexpected code
generation~\cite{chen2014,fermatub} to real-life
vulnerabilities~\cite{mitreub}.

Code snippets with a high risk of triggering UB optimizations are
provided in Listings~\ref{lst:ubo1},~\ref{lst:ubo2} and~\ref{lst:ubo3}.

\begin{lstlisting}[style=Cstyle, caption=Compiler assumes that dividing
a number by zero makes no sense and the whole block is deleted
(lib/mpi/mpi-pow.c in the Linux kernel), label={lst:ubo1}]
if (!msize)
	msize = 1 / msize; /* provoke a signal */
\end{lstlisting}

\begin{lstlisting}[style=Cstyle, caption={Compiler assumes that
in6ifa\_ifpwithaddr returns NULL then makes ipa6 NULL and deletes the if
check (sys/netinet6/nd6.c in the OpenBSD kernel)}, label={lst:ubo2}]
ifa = &in6ifa_ifpwithaddr(ifp,
	&satosin6(rt_key(rt))->sin6_addr)->ia_ifa;
if (ifa) {
	...
}
\end{lstlisting}

\begin{lstlisting}[style=Cstyle, caption=Comparing pointers that do not
point to the same aggregate or union is undefined behavior so the
compiler is free to return anything from this function
(sys/kern/subr\_hibernate.c in the OpenBSD kernel), label={lst:ubo3}]
static __inline int
hibe_cmp(struct hiballoc_entry *l, struct hiballoc_entry *r)
{
	return l < r ? -1 : (l > r);
}
\end{lstlisting}

The code shown in these examples was fixed up to this
day~\cite{ubo1sol,ubo2sol,ubo3sol} but the risk of existing code
triggering uncatched UB optimizations still persists.

To address these issues the research community created solutions that
tackle the problem from different angles. One approach was to introduce
new compiler improvements that would catch undefined behaviors either at
compile-time or at run-time. However such endeavours could not provide
the expected results.

On one hand, generating reports for all undefined behaviors at
compile-time is undecidable~\cite{hathhorn2015defining}.  Moreover,
generating such reports is unuseful in specific cases.
Listing~\ref{lst:uur}, for example, could generate reports such as:
\begin{itemize} \item pointer a may originate from a non-integral or
non-void pointer \item pointer a may be NULL \item variable b may be
uninitialized \end{itemize}

\begin{lstlisting}[style=Cstyle, caption=Code that may report false
undefined behavior, label={lst:uur}]
void foo(int *a, int b) {
	*a = b;
}
\end{lstlisting}

This is the case because the internal representation of the compiler may
not have enough context to report only the useful information about
undefined behaviors and because the compiler cannot understand the
intention of the programmer when issuing an UB optimization. In this
context, to issue UB optimizations is paradoxical. The compiler does not
have the context to find and report undefined behaviors, but it uses
undefined behaviors in order to generate code
transformations~\cite{lee2017taming}.

On the other hand, catching undefined behavior at run-time proves to be
an incomplete approach. The run-time checker would need to visit all the
states of the program in order to ensure that no undefined behavior is
triggered. To catch all states that may contain undefined behavior we
need to run the checker for as long as it requires, which may not be
desirable in most cases because it may take too much time. Checkers for
this task are IOC~\cite{dietz2015understanding}, UBsan~\cite{ubsan} and
various compiler flags such as GCC's -ftrapv and Clang's
-fcatch-undefined-behavior.

Another approach for run-time checking is to compare the unoptimized
code with the optimized code generated by the compiler. However program
equivalence is undecidable~\cite{sipser1996introduction}. Also,
decompilation might be used to compute the semantic distance between the
original C code and the decompiled optimized assembly code.  Doing so we
could spot the introduced UB optimizations and delete them later.
However decompilation is a hard problem in
general~\cite{cifuentes1995decompilation} because of type erasure.

Besides the introduction of compiler improvements, another solution
would be to issue additions to the standard that would provide more
robustness to the definition of undefined behavior. At the moment,
state-of-the-art compilers, such as GCC and Clang/LLVM, take a liberal
view of the standard and interpret it in a way that allows them to push
various dangerous optimizations. The opposite view is the constructivist
one, where the compiler implementations construct a robust definition of
undefined behavior, even if the standard imposes no strong requirements.
Until the standard makes it clear what approach it would take in the
future, implementations and developers need to decide their approach
based on the ambiguous definition provided in the standard.

Various academics and C programmers have complained throughout the years
about this situation. Linus Torvalds~\cite{linusgcc} said in 2016 on the
GCC mailing list (paranthesis mine):
\begin{displayquote}
The fact is, undefined compiler behavior is never a good idea. Not for
serious projects.

Performance doesn't come from occasional small and odd
micro-optimizations. I care about performance a lot, and I actually look
at generated code and do profiling etc. None of those three options
(-fno-strict-overflow, -fno-strict-aliasing and
-fno-deletel-null-pointer-checks) have *ever* shown up as issues. But
the incorrect code they generate? It has.
\end{displayquote}

John Regehr wrote in one of his blog posts:
\begin{displayquote}
One suspects that the C standard body simply got used to throwing
behaviors into the “undefined” bucket and got a little carried away.
Actually, since the C99 standard lists 191 different kinds of undefined
behavior, it’s fair to say they got a lot carried away.
\end{displayquote}

DJ Bernstein, one of the most important voice in writing cryptography
code, wrote:
\begin{displayquote}
Pretty much every real-world C
program is "undefined" according to the C "standard", and new compiler
"optimizations" often produce new security holes in the resulting object
code, as illustrated by

https://lwn.net/Articles/342330/
https://kb.isc.org/article/AA-01167

and many other examples. Crypto code isn't magically immune to this
\end{displayquote}

Bernstein's complaint was heard by GCC developers and they tried to
start an initiative for creating a boringcc dialect in GCC. However the
efforts is stopped because human resources are missing.

Finally, Dennis Ritchie also commented about the dangerous effect of
noalias, an early undefined behavior that was in the end dropped by
the ANSI C standard:
\begin{displayquote}
`Noalias' is much more dangerous; the committee is planting timebombs
that are sure to explode in people's faces.  Assigning an ordinary
pointer to a pointer to a `noalias' object is a license for the compiler
to undertake aggressive optimizations that are completely legal by the
committee's rules, but make hash of apparently safe programs.  Again,
the problem is most visible in the library; parameters declared `noalias
type *' are especially problematical. 
\end{displayquote}

While noalias does not exist in current standards, the "timebomb"
effects that Ritchie describes can be found in many other undefined
behaviors as described in the examples provided in this section.

\todo{talk about the discussions in GCC mailing list}
\todo{talk about what do you mean by the intention of the programmer}
