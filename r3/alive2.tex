\section{Finding new exploatations of undefined behavior}

We explored various flags that deal with the exploatation of undefined behavior.
Some of them were already integrated in LLVM, e.g. -fwrapv and some of them were
developed by us based on our previous experience and based on
LangRef~\cite{langref}. However, there is a third category of flags that we
developed based on automatic exploration using Alive2.

Alive2~\cite{lopes2021alive2} is an automatic verification tool for LLVM
optimizations. Roughly, after each optimization pass it checks whether the
Intermediate Representation (IR) contains undefinedness. This helps us find
places in the optimization pipeline that exploit undefined behavior.

We decided to patch Clang, the frontend for C/C++, when we found an undefined
behavior exploitation in the optimization pipeline of LLVM. By making sure that
we generate code free of undefined behavior directly from the source, i.e.
Clang, we made sure that further optimization cannot take any advantage or
further propagate the exploitation of undefined behavior. For example, instead
of patching each place in LLVM that takes advantage by division by 0, we
generated code from Clang that guarded each division so that LLVM cannot further
optimize the division.

% mention that we disabled inter procedural optimizations because Alive2 cannot
% work well with them.

The following is an example of undefined behavior detected using Alive2.
Listing~\ref{lst:is_sb_aq_enabled_c_code} contains a C function from the
AOM-AV1~\todo{cite} project that returns a value based on a pointer received as
parameter. Listing~\ref{lst:is_sb_aq_enabled_alive} contains the corresponding
Alive2 output for is_sb_aq_enabled. The output can be broken down in multiple
parts:
\begin{itemize}
  \item The IR before the optimization and the IR before the optimization, they
are delimited by \(=>\)
  \item Information about the validity of the transformation, in this case we
get an "Transformation doesn't verify! (unsound) ERROR: Source has guardable UB"
  \item Detailed information about the cause of the error including values that
triggered the error and the memory state
\end{itemize}

\begin{lstlisting}[style=Cstyle, caption={C code for is_sb_aq_enabled}, label={lst:is_sb_aq_enabled_c_code}]
static bool is_sb_aq_enabled(const AV1_COMP *const cpi) {
  return cpi->rc.sb64_target_rate >= 256;
}
\end{lstlisting}

\begin{lstlisting}[caption={Alive2 output on is_sb_aq_enabled}, label={lst:is_sb_aq_enabled_alive}]
define i1 @is_sb_aq_enabled(ptr noundef %cpi) null_pointer_is_valid zeroext {
%entry:
  %cpi.addr = alloca i64 8, align 8
  store ptr noundef %cpi, ptr %cpi.addr, align 1
  %0 = load ptr, ptr %cpi.addr, align 1
  %rc = gep inbounds ptr %0, 677024 x i32 0, 1 x i64 427536
  %sb64_target_rate = gep inbounds ptr %rc, 248 x i32 0, 1 x i64 16
  %1 = load i32, ptr %sb64_target_rate, align 1
  %cmp = icmp sge i32 %1, 256
  ret i1 %cmp
}
=>
define i1 @is_sb_aq_enabled(ptr noundef %cpi) null_pointer_is_valid zeroext {
%entry:
  %rc = gep inbounds ptr noundef %cpi, 677024 x i32 0, 1 x i64 427536
  %sb64_target_rate = gep inbounds ptr %rc, 248 x i32 0, 1 x i64 16
  %0 = load i32, ptr %sb64_target_rate, align 1
  %cmp = icmp sge i32 %0, 256
  ret i1 %cmp
}
Transformation doesn't verify! (unsound)
ERROR: Source has guardable UB

Example:
ptr noundef %cpi = pointer(non-local, block_id=0, offset=-388623)

Source:
ptr %cpi.addr = null
ptr %0 = pointer(non-local, block_id=0, offset=-388623)
ptr %rc = poison
ptr %sb64_target_rate = poison
i32 %1 = UB triggered!

SOURCE MEMORY STATE
===================
NON-LOCAL BLOCKS:
Block 0 >       size: 601368    align: 9223372036854775808      alloc type: 0   address: 0
Block 1 >       size: 8968      align: 4        alloc type: 0   address: 601368

LOCAL BLOCKS:
Block 2 >       size: 601368    align: 9223372036854775808      alloc type: 0   address: 0

Target:
ptr %rc = poison
ptr %sb64_target_rate = poison
i32 %0 = UB triggered!
\end{lstlisting}

One can spot the poison values in \%rc and \%sb64_target_rate from the detailed
information section of the output. They cause the subsequent "UB triggered!"
because as per
LangRef~\cite{load-semantics} when using a load instruction, "if pointer is not a
well-defined value, the behavior is undefined.". To stop this exploatation of
undefined behavior from taking place, we removed the \textit{inbounds} keyboard
from the GEP instruction directly from Clang. By removing \textit{inbounds} we
made sure that none of the cases described in~\cite{getelementptr-semantics} is
not triggered, hence no undefined behavior is not triggered.

By this method we created 5 more flags:
\begin{itemize}
  \item -fdrop-noalias-restrict-attr: Drop noalias attribute generated by the
restrict keyword
  \item -fdrop-align-attr: Drop align attribute
  \item -fdrop-deref-attr: Drop dereferenceable attribute
  \item -fdrop-ub-builtins: Drops builtin_assume_aligned and replaces builtin_unreachable with builtin_trap
  \item -fdrop-pure-const-attr: Drop pure and const function attributes
\end{itemize}

We also had plans to drop the noundef attribute but fortunately there already
existed a flag for that, callled "-Xclang -no-enable-noundef-analysis".
