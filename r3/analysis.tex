\section{Analysis of performance regressions}

Currently we are analysing a performance regression in the
simdjson-2.0.1~\cite{simdjsonbenchmark} benchmark on Intel. For the
-fdrop-align-attr there is a loss of 12.3\% performance compared to baseline. In
terms of raw performance, this underlies a throughput drop from 2 GB/s to 1.77
GB/s. 

The purpose of -fdrop-align-attr is to drop every \textit{align} attribute for
each argument of every function. By doing this we make sure that no undefined
behavior related to alignment is generated~\cite{align-semantics}. However as
seen in the above percentage, a good amount of performance is lost by using this
approach.

To find the functions that triggered the regression we used
elf_diff~\cite{elfdiff}, a tool for comparing ELF binaries in a visual way as
well as in a programatical way. Using elf_diff we were able to get an idea of
the changes caused by dropping the \textit{align} attribute. Then we gathered
all the affected functions and started a binary search to reduce to a minimum
the set of affected functions that also caused the peformance regression.

After finding the problematic function, Listing~\ref{lst:simdjson_ondemand_run},
we started to analyze how each argument of this function is affected by the
\textit{align} attribute, Listing~\ref{lst:simdjson_ondemand_run_llvm}

\begin{lstlisting}[language=C++, style=Cstyle, caption={Function that caused
performance regressions}, label={lst:simdjson_ondemand_run}]

partial_tweets::simdjson_ondemand::run(simdjson::padded_string& this, std::vector<partial_tweets::tweet<std::basic_string_view<char, std::char_traits<char> > > json, std::allocator<partial_tweets::tweet<std::basic_string_view<char, std::char_traits<char> > > > >& result)

\end{lstlisting}


\begin{lstlisting}[language=llvm, style=Cstyle, caption={LLVM representation of
arguments of partial_tweets::simdjson_ondemand::run}, label={lst:simdjson_ondemand_run_llvm}]

ptr noundef nonnull align 8 dereferenceable(48) %this, ptr noundef nonnull align 8 dereferenceable(16) %json, ptr noundef nonnull align 8 dereferenceable(24) %result

\end{lstlisting}

Even if every argument has an \textit{align} attribute, we found that that only
by dropping \textit{align} from the \textit{this} pointer, i.e. first parameter, and
keeping the attributes of the other parameters intact, the performance drops.

To find what optimization pass was causing the regerssion, we used the -mllvm
-print-after-all option with Clang and diff'ed the output with and without
\textit{align} enabled on the \textit{this} pointer,
Listing~\ref{lst:licm_diff}. We found that the Loop Invariant Code Motion (LICM)
pass was generating suboptimal code that fed to subsequent passes. More
specifically, because alignment information was missing, LICM was not able to
hoist instructions dependent on the \textit{this} pointer out of the main loop
which caused the generated code to be more expensive in terms of instructions
per loop iteration.

\begin{lstlisting}[language=diff, caption={Diff between the code generated by LICM with and
without the \textit{align} attribute on the \textit{this} pointer}, label={lst:licm_diff}]

*** IR Dump After LICMPass on while.body.i.i.i.i.i ***
 
 ; Preheader:
 while.body.i.lr.ph.i.i.i.i:                       ; preds = %if.end.i.i.i.i.i, %if.end.while.body.i.lr.ph.i_crit_edge.i.i.i
   %.ph.i.i.i.i = phi ptr [ %incdec.ptr.i.i.i.i.i.i.i.i, %if.end.i.i.i.i.i ], [ %add.ptr.i.i.i.i.i.i, %if.end.while.body.i.lr.ph.i_crit_edge.i.i.i ]
   %_depth.i.i78.i35.i.i.i.i = getelementptr inbounds %"class.simdjson::fallback::ondemand::json_iterator", ptr %doc, i64 0, i32 4
   %parser.i.i.i132.i38.i.i.i.i = getelementptr inbounds %"class.simdjson::fallback::ondemand::json_iterator", ptr %doc, i64 0, i32 1
   %error.i.i.i172.i39.i.i.i.i = getelementptr inbounds %"class.simdjson::fallback::ondemand::json_iterator", ptr %doc, i64 0, i32 3
   %implementation.i.i.i133.i.i.i.i.i = getelementptr inbounds %"class.simdjson::fallback::ondemand::parser", ptr %this, i64 0, i32 1
-  %39 = load ptr, ptr %implementation.i.i.i133.i.i.i.i.i, align 8
-  %n_structural_indexes2.i67.i.i134.i.i.i.i.i = getelementptr inbounds %"class.simdjson::internal::dom_parser_implementation", ptr %39, i64 0, i32 1
-  %structural_indexes.i68.i.i135.i.i.i.i.i = getelementptr inbounds %"class.simdjson::internal::dom_parser_implementation", ptr %39, i64 0, i32 2
   br label %while.body.i.i.i.i.i
 
 ; Loop:
 while.body.i.i.i.i.i:                             ; preds = %cleanup.cont.i.i.i9.i.i, %while.body.i.lr.ph.i.i.i.i

...

 sw.epilog.i.i139.i.i.i.i.i:                       ; preds = %if.then13.i.i127.i.i.i.i.i, %if.end.i.i118.i.i.i.i.i, %if.end.i.i118.i.i.i.i.i, %if.end.i.i118.i.i.i.i.i, %if.end.i.i118.i.i.i.i.i
+  %50 = load ptr, ptr %implementation.i.i.i133.i.i.i.i.i, align 8, !tbaa !35, !noalias !77
+  %n_structural_indexes2.i67.i.i134.i.i.i.i.i = getelementptr inbounds %"class.simdjson::internal::dom_parser_implementation", ptr %50, i64 0, i32 1
   %51 = load i32, ptr %n_structural_indexes2.i67.i.i134.i.i.i.i.i, align 8, !tbaa !67, !noalias !77
+  %structural_indexes.i68.i.i135.i.i.i.i.i = getelementptr inbounds %"class.simdjson::internal::dom_parser_implementation", ptr %50, i64 0, i32 2
   %conv.i69.i.i136.i.i.i.i.i = zext i32 %51 to i64
   %52 = load ptr, ptr %structural_indexes.i68.i.i135.i.i.i.i.i, align 8, !tbaa !35, !noalias !77
   %arrayidx.i.i5570.i.i137.i.i.i.i.i = getelementptr inbounds i32, ptr %52, i64 %conv.i69.i.i136.i.i.i.i.i

\end{lstlisting}

The instructions could not be hoisted because loads can only be hoisted if the
pointer is known to be dereferenceable and the pointer is at least as aligned as
the load. This requirement exists because not all hardware architectures support
unaligned load, e.g. SPARC. This imposes a limitation on architectures such as
x86 or ARM that do support unaligned loads.

In LLVM, this is translated to the following sequence of calls.
hoist~\cite{hoist} cannot be called because
isSafeToExecuteUnconditionally~\cite{isSafeToExecuteUnconditionally} fails on
the isSafeToSpeculativelyExecute~\cite{isSafeToSpeculativelyExecute} condition.
Going further through the call chain
isDereferenceableAndAlignedPointer~\cite{isDereferenceableAndAlignedPointer}
will fail because isAligned~\cite{isAligned} returns false as BA, i.e. the
alignment of the pointer, is 1 and Alignment, i.e. the alignment of the
load instruction, is 8.
